{
  "title": "Seed Collisions",
  "severity": "High",
  "description": "Seed collisions occur when two different sets of seeds generate the same Program Derived Address (PDA). In Solana, PDAs are deterministically generated addresses based on seeds and a program ID. When different seed inputs generate the same PDA, it can lead to unintended account overwrites, access control issues, or denial of service attacks or complete compromise.",
  "example_scenario": "Consider a program for a decentralized voting platform for various proposals and initiatives. Each voting session for a given proposal or initiative is created with a unique identifier, and users submit votes. The program uses PDAs for both voting sessions and individual votes, but does not ensure the uniqueness of the seeds used to derive these addresses. An attacker could craft a voting session with seeds that collide with another voting session's PDA, potentially disrupting the platform's operations by preventing legitimate votes or denying new initiatives from being added.",
  "insecure_example": "// Creating a Voting Session PDA\n#[derive(Accounts)]\n#[instruction(session_id: String)]\npub struct CreateVotingSession<'info> {\n    #[account(mut)]\n    pub organizer: Signer<'info>,\n    #[account(\n        init,\n        payer = organizer,\n        space = 8 + Product::SIZE,\n        seeds = [b\"session\", session_id.as_bytes()],\n    )]\n    pub voting_session: Account<'info, VotingSession>,\n    pub system_program: Program<'info, System>,\n}\n\n// Submitting a Vote PDA\n#[derive(Accounts)]\n#[instruction(session_id: String)]\npub struct SubmitVote<'info> {\n    #[account(mut)]\n    pub voter: Signer<'info>,\n    #[account(\n        init,\n        payer = voter,\n        space = 8 + Vote::SIZE,\n        seeds = [session_id.as_bytes(), voter.key().as_ref()]\n    )]\n    pub vote: Account<'info, Vote>,\n    pub system_program: Program<'info, System>,\n}",
  "secure_example": "// Creating a Voting Session PDA with unique prefixes\n#[derive(Accounts)]\n#[instruction(session_id: String)]\npub struct CreateVotingSession<'info> {\n    #[account(mut)]\n    pub organizer: Signer<'info>,\n    #[account(\n        init,\n        payer = organizer,\n        space = 8 + Product::SIZE,\n        seeds = [b\"voting_session\", session_id.as_bytes()],  // Unique prefix\n    )]\n    pub voting_session: Account<'info, VotingSession>,\n    pub system_program: Program<'info, System>,\n}\n\n// Submitting a Vote PDA with unique prefixes\n#[derive(Accounts)]\n#[instruction(session_id: String)]\npub struct SubmitVote<'info> {\n    #[account(mut)]\n    pub voter: Signer<'info>,\n    #[account(\n        init,\n        payer = voter,\n        space = 8 + Vote::SIZE,\n        seeds = [b\"vote\", session_id.as_bytes(), voter.key().as_ref()]  // Unique prefix\n    )]\n    pub vote: Account<'info, Vote>,\n    pub system_program: Program<'info, System>,\n}",
  "mitigation": "To mitigate the risk of seed collisions, developers should use unique prefixes for seeds across different PDAs in the same program, use unique identifiers (e.g., timestamps, user IDs, nonce values) to guarantee that a unique PDA is generated every time, and programmatically validate that a generated PDA does not collide with existing PDAs."
}
