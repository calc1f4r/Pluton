{
  "title": "Type Cosplay",
  "severity": "High",
  "description": "Type cosplay is a vulnerability where one account type is misrepresented as another due to a lack of type checks during deserialization. This can lead to the execution of unauthorized actions or data corruption, as the program would operate based on the incorrect assumption of the account's role or permissions. The vulnerability occurs when a program deserializes account data without verifying the account's type discriminator, allowing an attacker to pass arbitrary account data that looks similar in structure to a required account type.",
  "example_scenario": "Consider a program that manages access to admin operations based on a user's role. Each user account includes a role discriminator to distinguish between regular users and administrators. The program contains a function to update admin settings intended only for administrators. However, the program fails to check the account's discriminator and deserializes user account data without confirming whether the account is an administrator, potentially allowing a regular user to perform admin operations.",
  "insecure_example": "pub fn update_admin_settings(ctx: Context<UpdateSettings>) -> ProgramResult {\n    // Deserialize without checking the discriminator\n    let user = User::try_from_slice(&ctx.accounts.user.data.borrow()).unwrap();\n\n    // Sensitive update logic\n\n    msg!(\"Admin settings updated by: {}\", user.authority)\n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct UpdateSettings<'info> {\n    user: AccountInfo<'info>\n}\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct User {\n    authority: Pubkey,\n}",
  "secure_example": "pub fn update_admin_settings(ctx: Context<UpdateSettings>) -> ProgramResult {\n    let user = User::try_from_slice(&ctx.accounts.user.data.borrow()).unwrap();\n\n    // Verify the user's discriminator\n    if user.discriminant != AccountDiscriminant::Admin {\n        return Err(ProgramError::InvalidAccountData.into())\n    }\n    \n    // Sensitive update logic\n\n    msg!(\"Admin settings updated by: {}\", user.authority)\n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct UpdateSettings<'info> {\n    user: AccountInfo<'info>\n}\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct User {\n    discriminant: AccountDiscriminant,\n    authority: Pubkey,\n}\n\n#[derive(BorshSerialize, BorshDeserialize, PartialEq)]\npub enum AccountDiscriminant {\n    Admin,\n    // Other account types\n}",
  "mitigation": "To mitigate against this issue, developers should implement proper type discrimination by including and verifying account type discriminators during deserialization. This ensures that only accounts of the expected type can be used in specific operations, preventing attackers from impersonating different account types.",
  "anchor_mitigation": "Anchor simplifies the mitigation of type cosplay vulnerabilities by automatically managing discriminators for account times. This is done via the Account<'info, T> wrapper, where Anchor ensures type safety by automatically checking the discriminator during deserialization. This allows developers to focus more on their program's business logic rather than manually implementing various type checks."
}