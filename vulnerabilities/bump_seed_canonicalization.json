{
  "title": "Bump Seed Canonicalization",
  "severity": "High",
  "description": "Bump seed canonicalization is a vulnerability that arises when a program uses an attacker-supplied bump seed instead of the canonical bump seed when creating or validating PDAs (Program Derived Addresses). In Solana, PDAs are generated using seeds and a bump seed to ensure the address doesn't lie on the ed25519 curve. The canonical bump seed is the first valid bump (usually 255) that generates a valid PDA. When a program uses a non-canonical bump seed, it may validate a different address than intended, potentially allowing unauthorized access to privileged operations.",
  "example_scenario": "Consider a treasury program where only a specific PDA derived from a 'treasury' seed and the program ID can withdraw funds. If the program accepts a user-provided bump seed parameter instead of deriving and using the canonical bump, an attacker might find an alternative bump seed that generates a PDA they control, allowing them to drain the treasury.",
  "insecure_example": "// Insecure: using an attacker-controlled bump seed\npub fn process_withdrawal(ctx: Context<Withdrawal>, bump: u8, amount: u64) -> Result<()> {\n    // Validate using the provided bump seed\n    let seeds = &[b\"treasury\", &[bump]];\n    let expected_pda = Pubkey::create_program_address(seeds, ctx.program_id).unwrap();\n    \n    if ctx.accounts.treasury.key() != expected_pda {\n        return Err(ProgramError::InvalidAccountData.into());\n    }\n    \n    // Process withdrawal\n    let from = ctx.accounts.treasury.to_account_info();\n    let to = ctx.accounts.recipient.to_account_info();\n    **from.lamports.borrow_mut() -= amount;\n    **to.lamports.borrow_mut() += amount;\n    \n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct Withdrawal<'info> {\n    #[account(mut)]\n    pub treasury: AccountInfo<'info>,\n    #[account(mut)]\n    pub recipient: Signer<'info>,\n}",
  "secure_example": "// Secure: finding and using the canonical bump seed\npub fn process_withdrawal(ctx: Context<Withdrawal>, amount: u64) -> Result<()> {\n    // Derive the canonical bump seed\n    let (expected_pda, bump) = Pubkey::find_program_address(&[b\"treasury\"], ctx.program_id);\n    \n    if ctx.accounts.treasury.key() != expected_pda {\n        return Err(ProgramError::InvalidAccountData.into());\n    }\n    \n    // Use the canonical bump for signing\n    let seeds = &[b\"treasury\", &[bump]];\n    let signer_seeds = &[&seeds[..]];\n    \n    // Process withdrawal with PDA as signer\n    let from = ctx.accounts.treasury.to_account_info();\n    let to = ctx.accounts.recipient.to_account_info();\n    **from.lamports.borrow_mut() -= amount;\n    **to.lamports.borrow_mut() += amount;\n    \n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct Withdrawal<'info> {\n    #[account(mut)]\n    pub treasury: AccountInfo<'info>,\n    #[account(mut)]\n    pub recipient: Signer<'info>,\n}",
  "mitigation": "To mitigate this vulnerability, always use Pubkey::find_program_address() to find the canonical bump seed, rather than accepting a bump seed from user input. When validating a PDA, derive the canonical bump and use it for verification, or use Anchor's seeds and bump constraints to handle this validation automatically.",
  "anchor_mitigation": "// Anchor's seeds and bump constraint handles canonicalization automatically\n#[derive(Accounts)]\n#[instruction(amount: u64)]\npub struct Withdrawal<'info> {\n    #[account(\n        mut,\n        seeds = [b\"treasury\"],\n        bump,  // Anchor derives the canonical bump automatically\n    )]\n    pub treasury: AccountInfo<'info>,\n    #[account(mut)]\n    pub recipient: Signer<'info>,\n}"
}
