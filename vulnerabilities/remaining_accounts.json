{
  "title": "Remaining Accounts",
  "severity": "High",
  "description": "The 'remaining_accounts' vector in Solana programs allows for a flexible number of accounts to be passed to an instruction. However, it's a common vulnerability when programs fail to properly validate these accounts before using them. An attacker can exploit this by providing malicious accounts that the program might operate on without proper verification of ownership, type, or other constraints.",
  "example_scenario": "Consider a DEX program that processes swaps with optional fee accounts passed via remaining_accounts. If the program doesn't verify that these fee accounts are authorized fee recipients, an attacker could pass their own account as a fee recipient and steal funds that should go to the protocol's treasury.",
  "insecure_example": "// Insecure: Using remaining_accounts without proper validation\npub fn process_transaction(ctx: Context<ProcessTx>) -> Result<()> {\n    // Get remaining accounts\n    let remaining_accounts = ctx.remaining_accounts;\n    \n    // Process the remaining accounts without proper verification\n    if !remaining_accounts.is_empty() {\n        // First account is assumed to be the fee recipient\n        let fee_account = &remaining_accounts[0];\n        \n        // VULNERABILITY: No validation that fee_account is authorized\n        // Transfer fee to the account\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.user_wallet.to_account_info(),\n            to: fee_account.clone(),\n            authority: ctx.accounts.user.to_account_info(),\n        };\n        transfer(ctx.accounts.token_program.to_account_info(), cpi_accounts, fee_amount)?;\n    }\n    \n    Ok(())\n}",
  "secure_example": "// Secure: Properly validating remaining_accounts\npub fn process_transaction(ctx: Context<ProcessTx>) -> Result<()> {\n    // Get remaining accounts\n    let remaining_accounts = ctx.remaining_accounts;\n    \n    // Process the remaining accounts with proper verification\n    if !remaining_accounts.is_empty() {\n        // First account is assumed to be the fee recipient\n        let fee_account = &remaining_accounts[0];\n        \n        // Validate that the fee account is an authorized recipient\n        let authorized_pubkey = Pubkey::find_program_address(\n            &[b\"fee_recipient\"],\n            ctx.program_id,\n        ).0;\n        \n        if fee_account.key() != authorized_pubkey {\n            return Err(ProgramError::InvalidAccountData.into());\n        }\n        \n        // Also validate the ownership\n        if fee_account.owner != ctx.program_id {\n            return Err(ProgramError::IllegalOwner.into());\n        }\n        \n        // Now it's safe to transfer the fee\n        let cpi_accounts = Transfer {\n            from: ctx.accounts.user_wallet.to_account_info(),\n            to: fee_account.clone(),\n            authority: ctx.accounts.user.to_account_info(),\n        };\n        transfer(ctx.accounts.token_program.to_account_info(), cpi_accounts, fee_amount)?;\n    }\n    \n    Ok(())\n}",
  "mitigation": "To mitigate this vulnerability, implement thorough validation for all accounts in the remaining_accounts vector before performing any operations with them. Specifically:\n\n1. Verify account ownership (check that accounts are owned by the expected program)\n2. Validate account types (ensure accounts have the expected data structure)\n3. Check authorization (confirm that accounts have the necessary permissions)\n4. Verify relationships (ensure accounts have the correct relationships with other accounts)\n5. Consider using Anchor's built-in constraint system for remaining accounts when possible"
}

