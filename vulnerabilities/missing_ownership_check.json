{
  "title": "Missing Ownership Check",
  "severity": "Critical",
  "description": "A missing ownership check vulnerability occurs when a program fails to verify that the accounts passed into an instruction are owned by the expected program before processing them. In Solana's account model, any program can read data from any account, but only the account's owner can modify its data. Without proper ownership checks, a malicious user could pass in an account owned by another program (or no program at all), leading to unexpected behavior or security breaches.",
  "example_scenario": "Imagine a program that processes staking instructions for token accounts. The program reads the token balance from an account and credits rewards based on the amount staked. If the program fails to verify that the token account is owned by the Token Program, an attacker could pass in a fake account with arbitrary data that mimics a token account structure, potentially tricking the program into crediting rewards for tokens that don't actually exist.",
  "insecure_example": "pub fn process_stake(ctx: Context<StakeContext>) -> Result<()> {\n  // Read token account data without ownership verification\n  let token_data = ctx.accounts.token_account.data.borrow();\n  let token_account = TokenAccount::try_from_slice(&token_data)?;\n  \n  // Process staking logic based on potentially invalid data\n  let stake_amount = token_account.amount;\n  // ... rest of staking logic\n  \n  Ok(())\n}\n\n#[derive(Accounts)]\npub struct StakeContext<'info> {\n  #[account(mut)]\n  pub token_account: AccountInfo<'info>,\n  pub user: Signer<'info>,\n}",
  "secure_example": "pub fn process_stake(ctx: Context<StakeContext>) -> Result<()> {\n  // Verify token account ownership\n  if *ctx.accounts.token_account.owner != spl_token::id() {\n    return Err(ProgramError::IllegalOwner.into());\n  }\n  \n  // Now safely read token account data\n  let token_data = ctx.accounts.token_account.data.borrow();\n  let token_account = TokenAccount::try_from_slice(&token_data)?;\n  \n  // Process staking logic with verified data\n  let stake_amount = token_account.amount;\n  // ... rest of staking logic\n  \n  Ok(())\n}\n\n#[derive(Accounts)]\npub struct StakeContext<'info> {\n  #[account(mut)]\n  pub token_account: AccountInfo<'info>,\n  pub user: Signer<'info>,\n}",
  "mitigation": "To mitigate this vulnerability, always verify the owner of accounts before operating on them. For accounts that should be owned by your program, check that the owner matches your program ID. For accounts that should be owned by another program (like token accounts owned by the SPL Token program), check that the owner matches the expected program ID.",
  "anchor_mitigation": "#[derive(Accounts)]\npub struct StakeContext<'info> {\n  #[account(\n    mut,\n    owner = spl_token::id(),\n  )]\n  pub token_account: AccountInfo<'info>,\n  pub user: Signer<'info>,\n}\n\n// Or even better, use Anchor's token account wrapper\n#[derive(Accounts)]\npub struct StakeContext<'info> {\n  #[account(mut)]\n  pub token_account: Account<'info, TokenAccount>,\n  pub user: Signer<'info>,\n}"
}