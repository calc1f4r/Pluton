{
  "title": "Overflow and Underflow",
  "severity": "High",
  "description": "Arithmetic overflow and underflow vulnerabilities occur when a program performs arithmetic operations that exceed the limits of the data type, potentially leading to unexpected behavior. In Solana programs, these vulnerabilities are particularly dangerous when dealing with financial calculations, as they can lead to manipulation of token amounts, fees, or other critical values.",
  "example_scenario": "Consider a DEX with a fee calculation that uses something like amount * fee_rate / 10000 for a 0.3% fee. If a malicious user sends an extraordinarily large amount that causes an overflow in the multiplication step, they might be able to avoid fees entirely or even drain assets from the protocol.",
  "insecure_example": "// Insecure: vulnerable to overflow/underflow\npub fn transfer(ctx: Context<Transfer>, amount: u64) -> Result<()> {\n    let src_account = &mut ctx.accounts.src_token_account;\n    let dst_account = &mut ctx.accounts.dst_token_account;\n    \n    // VULNERABILITY: No check for underflow\n    src_account.amount = src_account.amount - amount; // Can underflow\n    \n    // VULNERABILITY: No check for overflow\n    dst_account.amount = dst_account.amount + amount; // Can overflow\n    \n    Ok(())\n}",
  "secure_example": "// Secure: Using checked operations\npub fn transfer(ctx: Context<Transfer>, amount: u64) -> Result<()> {\n    let src_account = &mut ctx.accounts.src_token_account;\n    let dst_account = &mut ctx.accounts.dst_token_account;\n    \n    // Safely subtract with a check for underflow\n    src_account.amount = src_account.amount.checked_sub(amount)\n        .ok_or(ProgramError::InsufficientFunds)?;\n    \n    // Safely add with a check for overflow\n    dst_account.amount = dst_account.amount.checked_add(amount)\n        .ok_or(ProgramError::Overflow)?;\n    \n    Ok(())\n}\n\n// Alternative secure approach: using Anchor's token program\npub fn transfer(ctx: Context<Transfer>, amount: u64) -> Result<()> {\n    // Use the SPL token program's transfer function which handles overflow/underflow checks\n    token::transfer(\n        CpiContext::new(\n            ctx.accounts.token_program.to_account_info(),\n            token::Transfer {\n                from: ctx.accounts.src_token_account.to_account_info(),\n                to: ctx.accounts.dst_token_account.to_account_info(),\n                authority: ctx.accounts.owner.to_account_info(),\n            },\n        ),\n        amount,\n    )?;\n    \n    Ok(())\n}",
  "mitigation": "To mitigate overflow and underflow vulnerabilities:\n\n1. Use checked arithmetic operations (checked_add, checked_sub, checked_mul, checked_div) that return None when overflow/underflow would occur\n2. Enable overflow checks in Cargo.toml with `overflow-checks = true` in the [profile.release] section\n3. Use the saturating_* variants when appropriate (e.g., when you want to clamp at the max/min values)\n4. For token operations, use the SPL token program's functions which already include safety checks\n5. Consider using high-precision decimal libraries for complex financial calculations\n6. Explicitly validate input parameters to ensure they are within acceptable ranges"
}