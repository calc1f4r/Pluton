use anchor_lang::prelude::*;
use solana_program::pubkey::Pubkey;

declare_id!("BumpCANon1CA1ization11111111111111111111111");

#[program]
pub mod bump_seed_test {
    use super::*;

    // VULNERABILITY 1: Using create_program_address with user-supplied bump
    pub fn insecure_withdraw(ctx: Context<InsecureWithdraw>, bump: u8, amount: u64) -> Result<()> {
        // Using create_program_address with user-supplied bump
        let seeds = &[b"treasury", &[bump]];
        let expected_pda = Pubkey::create_program_address(seeds, ctx.program_id)?;
        
        // Check if the PDA matches the treasury account
        if ctx.accounts.treasury.key() != expected_pda {
            return Err(ProgramError::InvalidArgument.into());
        }
        
        // Transfer funds
        **ctx.accounts.treasury.to_account_info().try_borrow_mut_lamports()? -= amount;
        **ctx.accounts.recipient.try_borrow_mut_lamports()? += amount;
        
        Ok(())
    }
    
    // VULNERABILITY 2: Hardcoded non-canonical bump
    pub fn hardcoded_bump_withdraw(ctx: Context<HardcodedBumpWithdraw>, amount: u64) -> Result<()> {
        // Using a hardcoded bump that might not be canonical
        let bump = 5; // Arbitrary non-canonical bump
        let seeds = &[b"treasury", &[bump]];
        let expected_pda = Pubkey::create_program_address(seeds, ctx.program_id)?;
        
        // Check if the PDA matches the treasury account
        if ctx.accounts.treasury.key() != expected_pda {
            return Err(ProgramError::InvalidArgument.into());
        }
        
        // Transfer funds
        **ctx.accounts.treasury.to_account_info().try_borrow_mut_lamports()? -= amount;
        **ctx.accounts.recipient.try_borrow_mut_lamports()? += amount;
        
        Ok(())
    }
    
    // SECURE VERSION: Using find_program_address for canonical bump
    pub fn secure_withdraw(ctx: Context<SecureWithdraw>, amount: u64) -> Result<()> {
        // Derive the canonical bump
        let (expected_pda, _bump) = Pubkey::find_program_address(&[b"treasury"], ctx.program_id);
        
        // Check if the PDA matches the treasury account
        if ctx.accounts.treasury.key() != expected_pda {
            return Err(ProgramError::InvalidArgument.into());
        }
        
        // Transfer funds
        **ctx.accounts.treasury.to_account_info().try_borrow_mut_lamports()? -= amount;
        **ctx.accounts.recipient.try_borrow_mut_lamports()? += amount;
        
        Ok(())
    }
    
    // SECURE VERSION with Anchor: Store canonical bump
    pub fn initialize_treasury(ctx: Context<InitializeTreasury>) -> Result<()> {
        // Store the canonical bump for future reference
        ctx.accounts.treasury.bump = ctx.bumps.treasury;
        ctx.accounts.treasury.balance = 0;
        
        Ok(())
    }
    
    // SECURE VERSION with Anchor: Using stored canonical bump
    pub fn anchor_secure_withdraw(ctx: Context<AnchorSecureWithdraw>, amount: u64) -> Result<()> {
        // Anchor has already verified the PDA using the canonical bump stored in the account
        
        // Transfer funds
        **ctx.accounts.treasury.to_account_info().try_borrow_mut_lamports()? -= amount;
        **ctx.accounts.recipient.try_borrow_mut_lamports()? += amount;
        
        Ok(())
    }
}

#[derive(Accounts)]
pub struct InsecureWithdraw<'info> {
    /// CHECK: Vulnerable - uses user-supplied bump
    #[account(mut)]
    pub treasury: AccountInfo<'info>,
    
    #[account(mut)]
    pub recipient: Signer<'info>,
}

#[derive(Accounts)]
pub struct HardcodedBumpWithdraw<'info> {
    /// CHECK: Vulnerable - uses hardcoded bump
    #[account(mut)]
    pub treasury: AccountInfo<'info>,
    
    #[account(mut)]
    pub recipient: Signer<'info>,
}

#[derive(Accounts)]
pub struct SecureWithdraw<'info> {
    /// CHECK: Secure - derives and checks against canonical bump
    #[account(mut)]
    pub treasury: AccountInfo<'info>,
    
    #[account(mut)]
    pub recipient: Signer<'info>,
}

#[derive(Accounts)]
pub struct InitializeTreasury<'info> {
    #[account(
        init,
        payer = payer,
        space = 8 + 8 + 1, // discriminator + balance + bump
        seeds = [b"treasury"],
        bump
    )]
    pub treasury: Account<'info, Treasury>,
    
    #[account(mut)]
    pub payer: Signer<'info>,
    
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct AnchorSecureWithdraw<'info> {
    #[account(
        mut,
        seeds = [b"treasury"],
        bump = treasury.bump // Using stored bump is efficient and secure
    )]
    pub treasury: Account<'info, Treasury>,
    
    #[account(mut)]
    pub recipient: Signer<'info>,
}

#[account]
pub struct Treasury {
    pub balance: u64,
    pub bump: u8,
} 