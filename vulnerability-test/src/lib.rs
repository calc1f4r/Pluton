use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount};
use solana_program::pubkey::Pubkey;
use solana_program::program::{invoke, invoke_signed};
use solana_program::instruction::Instruction;
use solana_program::account_info::AccountInfo;

declare_id!("VuLnTesT111111111111111111111111111111111");

#[program]
pub mod vulnerability_test {
    use super::*;

    // VULNERABILITY 1: Missing account data matching check
    // No validation that authority matches the stored authority
    pub fn update_settings(ctx: Context<UpdateSettings>, new_value: u64) -> Result<()> {
        // No validation that ctx.accounts.authority.key() matches config.authority
        ctx.accounts.config.value = new_value;
        Ok(())
    }

    // VULNERABILITY 1B: More explicit account data matching vulnerability
    pub fn withdraw_funds(ctx: Context<WithdrawFunds>, amount: u64) -> Result<()> {
        // Should validate vault.owner == authority.key() but doesn't
        **ctx.accounts.vault.to_account_info().try_borrow_mut_lamports()? -= amount;
        **ctx.accounts.receiver.try_borrow_mut_lamports()? += amount;
        Ok(())
    }

    // VULNERABILITY 2: Type cosplay - no type verification
    pub fn insecure_process(ctx: Context<InsecureProcess>) -> Result<()> {
        // Deserializes account data without checking type discriminator
        let account_data = ctx.accounts.data_account.try_borrow_data()?;
        let _unchecked_data = SomeAccount::try_from_slice(&account_data)?;
        msg!("Processed data: {}", _unchecked_data.value);
        Ok(())
    }

    // VULNERABILITY 2B: More explicit type cosplay vulnerability 
    pub fn process_admin_action(ctx: Context<AdminAction>) -> Result<()> {
        // Cast raw account to admin type without verifying discriminator
        let account_data = ctx.accounts.account.try_borrow_data()?;
        
        // No check for account type/discriminator before using
        let admin_data = AdminAccount::try_from_slice(&account_data)?;
        
        msg!("Admin action by: {}", admin_data.authority);
        Ok(())
    }

    // VULNERABILITY 3: Arbitrary CPI - no program ID validation
    pub fn transfer_tokens(ctx: Context<TransferTokens>, amount: u64) -> Result<()> {
        // No validation that token_program is actually the SPL token program
        let cpi_ctx = CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            token::Transfer {
                from: ctx.accounts.source.to_account_info(),
                to: ctx.accounts.destination.to_account_info(),
                authority: ctx.accounts.authority.to_account_info(),
            },
        );
        
        // Performing CPI without verifying the program ID
        token::transfer(cpi_ctx, amount)?;
        Ok(())
    }
    
    // VULNERABILITY 3B: Direct invoke CPI with no program validation
    pub fn direct_invoke_cpi(ctx: Context<DirectCpi>, data: Vec<u8>) -> Result<()> {
        let accounts = ctx.remaining_accounts.to_vec();
        
        // Creating instruction with user-supplied program ID without validation
        let ix = Instruction {
            program_id: *ctx.accounts.target_program.key,
            accounts: accounts.iter().map(|a| a.clone()).collect(),
            data,
        };
        
        // Directly invoking without validating the program ID
        invoke(&ix, &[ctx.accounts.target_program.clone()].iter().chain(accounts.iter()).collect::<Vec<&AccountInfo>>())?;
        
        // After CPI, accessing account data without reload
        let data = ctx.accounts.data_account.try_borrow_data()?;
        msg!("Data length after CPI: {}", data.len());
        
        Ok(())
    }
}

#[derive(Accounts)]
pub struct UpdateSettings<'info> {
    #[account(mut)]
    pub config: Account<'info, ConfigAccount>,
    
    // VULNERABILITY: Missing has_one = authority constraint
    pub authority: Signer<'info>,
}

#[derive(Accounts)]
pub struct WithdrawFunds<'info> {
    #[account(mut)]
    pub vault: Account<'info, VaultAccount>,
    
    #[account(mut)]
    pub receiver: AccountInfo<'info>,
    
    // VULNERABILITY: No validation that authority matches vault.owner
    pub authority: Signer<'info>,
}

#[derive(Accounts)]
pub struct InsecureProcess<'info> {
    // VULNERABILITY: Using raw AccountInfo instead of typed Account<T>
    #[account(mut)]
    pub data_account: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct AdminAction<'info> {
    // VULNERABILITY: Using unchecked AccountInfo
    pub account: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct TransferTokens<'info> {
    #[account(mut)]
    pub source: Account<'info, TokenAccount>,
    #[account(mut)]
    pub destination: Account<'info, TokenAccount>,
    pub authority: Signer<'info>,
    
    // VULNERABILITY: Using AccountInfo instead of Program<'info, Token>
    // which would verify the program ID automatically
    pub token_program: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct DirectCpi<'info> {
    #[account(mut)]
    pub data_account: AccountInfo<'info>,
    
    // VULNERABILITY: No validation of program ID
    pub target_program: AccountInfo<'info>,
    
    pub signer: Signer<'info>,
}

#[account]
pub struct ConfigAccount {
    pub authority: Pubkey,
    pub value: u64,
}

#[account]
pub struct VaultAccount {
    pub owner: Pubkey,
    pub balance: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct SomeAccount {
    pub value: u64,
}

#[derive(AnchorSerialize, AnchorDeserialize, Clone)]
pub struct AdminAccount {
    pub authority: Pubkey,
} 